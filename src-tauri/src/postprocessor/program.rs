use super::block::BlockBuilder;
use super::config::{ArcFormat, PostProcessorConfig};
use super::modal::ModalState;
use super::PostProcessorError;
use super::{
    arcs,
    formatter::{format_coord, render_template, TemplateContext},
};
use crate::toolpath::types::{CutPoint, MoveKind, PassKind, ToolOrientation};
use crate::toolpath::Toolpath;

/// Tool library data needed for G-code template substitution.
/// The IPC commands build this from project.tools before calling generate().
#[derive(Debug, Clone)]
pub struct ToolInfo {
    pub number: u32,
    pub diameter: f64,
    pub description: String,
}

pub struct GenerateOptions {
    pub program_number: Option<u32>,
    pub include_comments: bool,
}

/// Assembles a complete G-code program from one or more toolpaths.
///
/// Orchestrates all post-processor submodules: modal state tracking, arc
/// conversion, template substitution, and block formatting.
pub fn assemble(
    toolpaths: &[Toolpath],
    tool_infos: &[ToolInfo],
    config: &PostProcessorConfig,
    options: &GenerateOptions,
) -> Result<String, PostProcessorError> {
    let mut out = String::new();
    let mut line_num = config.format.line_number_start;
    let program_number = options.program_number.unwrap_or(config.program.number);

    // 1. Opening % delimiter
    if config.format.percent_delimiters {
        out.push('%');
        out.push_str(&config.format.eol);
    }

    // 2. Program number line — never carries an N-word (like the % delimiter)
    out.push_str(&format!(
        "{}{}",
        config.program.number_prefix, program_number
    ));
    out.push_str(&config.format.eol);

    // 3. Generation comment
    if options.include_comments {
        let comment = format!(
            "{}Generated by jamiecam{}",
            config.program.comment_open, config.program.comment_close
        );
        push_raw(&mut out, &comment, &mut line_num, config);
    }

    // 4. Header lines
    for line in &config.program.header {
        push_raw(&mut out, line, &mut line_num, config);
    }

    // 5+6. Tool changes and motion
    let mut modal = ModalState::new();
    let mut last_tool: Option<u32> = None;

    for toolpath in toolpaths {
        if last_tool != Some(toolpath.tool_number) {
            modal.reset();

            let tool_info = tool_infos.iter().find(|t| t.number == toolpath.tool_number);
            let ctx = TemplateContext {
                tool_number: toolpath.tool_number,
                tool_diameter: tool_info.map_or(0.0, |t| t.diameter),
                tool_description: tool_info.map_or_else(String::new, |t| t.description.clone()),
                spindle_speed: toolpath.spindle_speed,
                feed_rate: toolpath.feed_rate,
                program_number,
            };

            for template in &config.tool_change.pre {
                push_raw(
                    &mut out,
                    &render_template(template, &ctx),
                    &mut line_num,
                    config,
                );
            }
            push_raw(
                &mut out,
                &render_template(&config.tool_change.command, &ctx),
                &mut line_num,
                config,
            );
            for template in &config.tool_change.post {
                push_raw(
                    &mut out,
                    &render_template(template, &ctx),
                    &mut line_num,
                    config,
                );
            }

            last_tool = Some(toolpath.tool_number);
        }

        for pass in &toolpath.passes {
            if options.include_comments {
                let label = pass_comment_label(&pass.kind, config);
                push_raw(&mut out, &label, &mut line_num, config);
            }

            for cut in &pass.cuts {
                if let Some(ToolOrientation::FiveAxis { .. }) = &cut.tool_orientation {
                    return Err(PostProcessorError::NotSupported(
                        "5-axis orientation not supported".to_string(),
                    ));
                }
                emit_cut(cut, toolpath, &mut modal, &mut line_num, config, &mut out)?;
            }
        }
    }

    // 7. Footer lines
    for line in &config.program.footer {
        push_raw(&mut out, line, &mut line_num, config);
    }

    // 8. Closing % delimiter
    if config.format.percent_delimiters {
        out.push('%');
        out.push_str(&config.format.eol);
    }

    Ok(out)
}

fn pass_comment_label(kind: &PassKind, config: &PostProcessorConfig) -> String {
    let name = match kind {
        PassKind::SpringPass => return "; *** SPRING PASS ***".to_string(),
        PassKind::Cutting => "Cutting pass",
        PassKind::Linking => "Linking pass",
        PassKind::LeadIn => "Lead-in",
        PassKind::LeadOut => "Lead-out",
    };
    format!(
        "{}{}{}",
        config.program.comment_open, name, config.program.comment_close
    )
}

/// Emits a raw G-code text line, prepending an N-word if line numbering is enabled.
fn push_raw(out: &mut String, text: &str, line_num: &mut u32, config: &PostProcessorConfig) {
    if config.format.line_numbers && !text.is_empty() {
        out.push_str(&format!("N{}{}", line_num, config.format.word_separator));
        *line_num = line_num.saturating_add(config.format.line_number_increment);
    }
    out.push_str(text);
    out.push_str(&config.format.eol);
}

/// Returns the next line number and advances the counter, or `None` if line numbering is off.
fn next_line_num(line_num: &mut u32, config: &PostProcessorConfig) -> Option<u32> {
    if config.format.line_numbers {
        let n = *line_num;
        *line_num = line_num.saturating_add(config.format.line_number_increment);
        Some(n)
    } else {
        None
    }
}

/// Emits one G-code block for a single cut point, applying modal suppression.
fn emit_cut(
    cut: &CutPoint,
    toolpath: &Toolpath,
    modal: &mut ModalState,
    line_num: &mut u32,
    config: &PostProcessorConfig,
    out: &mut String,
) -> Result<(), PostProcessorError> {
    let pos = &cut.position;

    match &cut.move_kind {
        MoveKind::Rapid => {
            let code = config.motion.rapid.as_str();
            let emit_m = modal.should_emit_motion(code);
            let emit_x = modal.should_emit_coord('X', pos.x);
            let emit_y = modal.should_emit_coord('Y', pos.y);
            let emit_z = modal.should_emit_coord('Z', pos.z);
            let mut bb = BlockBuilder::new();
            if emit_m {
                bb = bb.motion(code);
            }
            if emit_x {
                bb = bb.axis('X', pos.x);
            }
            if emit_y {
                bb = bb.axis('Y', pos.y);
            }
            if emit_z {
                bb = bb.axis('Z', pos.z);
            }
            let ln = next_line_num(line_num, config);
            out.push_str(&bb.build().render(ln, config));
        }

        MoveKind::Feed => {
            let code = config.motion.linear.as_str();
            let emit_m = modal.should_emit_motion(code);
            let emit_x = modal.should_emit_coord('X', pos.x);
            let emit_y = modal.should_emit_coord('Y', pos.y);
            let emit_z = modal.should_emit_coord('Z', pos.z);
            let emit_f = modal.should_emit_feed(toolpath.feed_rate);
            let mut bb = BlockBuilder::new();
            if emit_m {
                bb = bb.motion(code);
            }
            if emit_x {
                bb = bb.axis('X', pos.x);
            }
            if emit_y {
                bb = bb.axis('Y', pos.y);
            }
            if emit_z {
                bb = bb.axis('Z', pos.z);
            }
            if emit_f {
                bb = bb.feed(toolpath.feed_rate);
            }
            let ln = next_line_num(line_num, config);
            out.push_str(&bb.build().render(ln, config));
        }

        MoveKind::Arc {
            center,
            end,
            clockwise,
        } => {
            let code = if *clockwise {
                config.motion.arc_cw.as_str()
            } else {
                config.motion.arc_ccw.as_str()
            };
            let emit_m = modal.should_emit_motion(code);
            let emit_x = modal.should_emit_coord('X', end.x);
            let emit_y = modal.should_emit_coord('Y', end.y);
            let emit_z = modal.should_emit_coord('Z', end.z);
            let emit_f = modal.should_emit_feed(toolpath.feed_rate);
            let mut bb = BlockBuilder::new();
            if emit_m {
                bb = bb.motion(code);
            }
            if emit_x {
                bb = bb.axis('X', end.x);
            }
            if emit_y {
                bb = bb.axis('Y', end.y);
            }
            if emit_z {
                bb = bb.axis('Z', end.z);
            }
            match &config.motion.arc_format {
                ArcFormat::Ijk => {
                    let (i, j, k) = arcs::ijk_from_arc(pos, center);
                    bb = bb.arc_param('I', i).arc_param('J', j).arc_param('K', k);
                }
                ArcFormat::R => {
                    let r = arcs::r_from_arc(pos, end, center, *clockwise)?;
                    bb = bb.arc_param('R', r);
                }
            }
            if emit_f {
                bb = bb.feed(toolpath.feed_rate);
            }
            let ln = next_line_num(line_num, config);
            out.push_str(&bb.build().render(ln, config));
        }

        MoveKind::Dwell { seconds } => {
            // G4 P{time} — BlockBuilder has no P-word slot, so emit as a raw line.
            let p_val = format_coord(
                *seconds,
                config.format.decimal_places,
                !config.format.trailing_zeros,
                config.format.leading_zero_suppression,
            );
            let text = format!(
                "G4{}{}{}",
                config.format.word_separator, config.words.dwell, p_val,
            );
            push_raw(out, &text, line_num, config);
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::Vec3;
    use crate::postprocessor::config;
    use crate::toolpath::types::{CutPoint, MoveKind, Pass, PassKind, ToolOrientation, Toolpath};
    use uuid::Uuid;

    fn minimal_toml() -> String {
        r#"
[meta]
id = "test"
name = "Test"
description = "Test controller"
version = "1.0"
author = "Test"

[machine]
units = "metric"
max_axes = 3

[format]
line_numbers = false
line_number_start = 10
line_number_increment = 10
line_number_max = 9999
decimal_places = 3
trailing_zeros = false
leading_zero_suppression = false
word_separator = " "
eol = "\n"
percent_delimiters = false
block_delete_char = ""

[axes]
x = "X"
y = "Y"
z = "Z"

[program]
number_prefix = "O"
number = 1000
number_format = "%04d"
comment_open = "("
comment_close = ")"
header = []
footer = []

[tool_change]
pre = []
command = "T{tool_number} M06"
post = []
suppress_first_if_t1 = false

[motion]
rapid = "G00"
linear = "G01"
arc_cw = "G02"
arc_ccw = "G03"
arc_format = "ijk"
plane_xy = "G17"
plane_xz = "G18"
plane_yz = "G19"

[words]
feed = "F"
spindle = "S"
tool = "T"
tool_offset = "H"
dwell = "P"
feed_per_min = "G94"
feed_per_rev = "G95"
inverse_time = "G93"
absolute = "G90"
incremental = "G91"

[spindle]
on_cw = "M03"
on_ccw = "M04"
off = "M05"
max_rpm = 15000

[coolant]
flood = "M08"
mist = "M07"
air = "M07"
off = "M09"

[cycles]
supported = false

[misc]
optional_stop = "M01"
program_stop = "M00"
"#
        .to_string()
    }

    fn default_config() -> config::PostProcessorConfig {
        config::parse(&minimal_toml()).expect("test TOML must be valid")
    }

    #[test]
    fn basic_rapid_and_feed_toolpath() {
        let cfg = default_config();
        let toolpath = Toolpath {
            operation_id: Uuid::nil(),
            tool_number: 1,
            spindle_speed: 8000.0,
            feed_rate: 500.0,
            passes: vec![Pass {
                kind: PassKind::Cutting,
                cuts: vec![
                    CutPoint {
                        position: Vec3 {
                            x: 0.0,
                            y: 0.0,
                            z: 5.0,
                        },
                        move_kind: MoveKind::Rapid,
                        tool_orientation: None,
                    },
                    CutPoint {
                        position: Vec3 {
                            x: 10.0,
                            y: 0.0,
                            z: 0.0,
                        },
                        move_kind: MoveKind::Feed,
                        tool_orientation: None,
                    },
                ],
            }],
        };

        let opts = GenerateOptions {
            program_number: None,
            include_comments: false,
        };

        let result = assemble(&[toolpath], &[], &cfg, &opts).expect("assembly must succeed");

        assert!(
            result.contains("G00"),
            "expected G00 rapid word, got:\n{}",
            result
        );
        assert!(
            result.contains("G01"),
            "expected G01 feed word, got:\n{}",
            result
        );
    }

    #[test]
    fn tool_change_command_is_emitted() {
        let cfg = default_config();
        let toolpath = Toolpath {
            operation_id: Uuid::nil(),
            tool_number: 5,
            spindle_speed: 6000.0,
            feed_rate: 300.0,
            passes: vec![],
        };
        let opts = GenerateOptions {
            program_number: None,
            include_comments: false,
        };
        let result = assemble(&[toolpath], &[], &cfg, &opts).unwrap();
        assert!(
            result.contains("T5 M06"),
            "expected T5 M06 tool change, got:\n{}",
            result
        );
    }

    #[test]
    fn program_number_line_is_emitted() {
        let cfg = default_config();
        let opts = GenerateOptions {
            program_number: Some(42),
            include_comments: false,
        };
        let result = assemble(&[], &[], &cfg, &opts).unwrap();
        assert!(
            result.contains("O42"),
            "expected O42 program number, got:\n{}",
            result
        );
    }

    #[test]
    fn program_number_line_has_no_line_number_when_line_numbers_enabled() {
        // O-line must never carry an N-word even when line_numbers = true
        let toml = minimal_toml().replace("line_numbers = false", "line_numbers = true");
        let cfg = config::parse(&toml).unwrap();
        let opts = GenerateOptions {
            program_number: Some(1000),
            include_comments: false,
        };
        let result = assemble(&[], &[], &cfg, &opts).unwrap();
        let first_line = result.lines().next().expect("output must be non-empty");
        assert_eq!(
            first_line, "O1000",
            "O-line must not have N-word, got: {:?}",
            first_line
        );
    }

    #[test]
    fn percent_delimiters_wrap_program() {
        let toml =
            minimal_toml().replace("percent_delimiters = false", "percent_delimiters = true");
        let cfg = config::parse(&toml).unwrap();
        let opts = GenerateOptions {
            program_number: None,
            include_comments: false,
        };
        let result = assemble(&[], &[], &cfg, &opts).unwrap();
        assert!(
            result.starts_with('%'),
            "expected opening %, got:\n{}",
            result
        );
        assert!(
            result.trim_end().ends_with('%'),
            "expected closing %, got:\n{}",
            result
        );
    }

    #[test]
    fn five_axis_orientation_returns_error() {
        let cfg = default_config();
        let toolpath = Toolpath {
            operation_id: Uuid::nil(),
            tool_number: 1,
            spindle_speed: 8000.0,
            feed_rate: 500.0,
            passes: vec![Pass {
                kind: PassKind::Cutting,
                cuts: vec![CutPoint {
                    position: Vec3 {
                        x: 0.0,
                        y: 0.0,
                        z: 0.0,
                    },
                    move_kind: MoveKind::Feed,
                    tool_orientation: Some(ToolOrientation::FiveAxis {
                        tool_axis: Vec3 {
                            x: 0.0,
                            y: 0.0,
                            z: 1.0,
                        },
                    }),
                }],
            }],
        };
        let opts = GenerateOptions {
            program_number: None,
            include_comments: false,
        };
        let err = assemble(&[toolpath], &[], &cfg, &opts).unwrap_err();
        assert!(matches!(err, PostProcessorError::NotSupported(_)));
    }

    #[test]
    fn modal_suppresses_repeated_motion_code() {
        let cfg = default_config();
        let toolpath = Toolpath {
            operation_id: Uuid::nil(),
            tool_number: 1,
            spindle_speed: 8000.0,
            feed_rate: 500.0,
            passes: vec![Pass {
                kind: PassKind::Cutting,
                cuts: vec![
                    CutPoint {
                        position: Vec3 {
                            x: 0.0,
                            y: 0.0,
                            z: 0.0,
                        },
                        move_kind: MoveKind::Feed,
                        tool_orientation: None,
                    },
                    CutPoint {
                        position: Vec3 {
                            x: 10.0,
                            y: 0.0,
                            z: 0.0,
                        },
                        move_kind: MoveKind::Feed,
                        tool_orientation: None,
                    },
                ],
            }],
        };
        let opts = GenerateOptions {
            program_number: None,
            include_comments: false,
        };
        let result = assemble(&[toolpath], &[], &cfg, &opts).unwrap();
        // G01 should appear only once (suppressed on second feed move)
        let count = result.matches("G01").count();
        assert_eq!(
            count, 1,
            "G01 should appear exactly once (modal), got:\n{}",
            result
        );
    }
}
