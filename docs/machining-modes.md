# JamieCam Machining Modes

## Overview

A JamieCam project has two orthogonal configuration axes:

- **Input type** — what the source geometry is (vector artwork, heightmap, solid model)
- **Machine configuration** — how many axes the target machine has and how they move

These two axes combine to produce the set of available operations and determine
which parts of the architecture are active. Not every combination is meaningful;
the valid pairings are described below.

```
                        MACHINE CONFIGURATION
                   ┌────────┬────────┬────────┬────────┬────────┐
                   │ 3-axis │ 4-axis │ Rotary │ Multi- │ 5-axis │
                   │  mill  │ simul. │  X,Z,θ │ setup  │        │
 ──────────────────┼────────┼────────┼────────┼────────┼────────┤
 I  2D Vector      │   ✓    │        │        │        │        │
 N  V-carve        │   ✓    │        │  ✓     │        │        │
 P  Relief/Height  │   ✓    │        │  ✓     │        │        │
 U  Solid 3D       │   ✓    │   ✓    │        │   ✓    │   ✓    │
 T  ───────────────┴────────┴────────┴────────┴────────┴────────┘
```

Each row below describes a mode in full — its input format, the operations it
enables, the UI it presents, and its architecture implications.

---

## Mode 1: 2D Vector

**What it is:** The input is 2D vector artwork (SVG, DXF). The user assigns
cutting operations to paths or regions: profile cuts (inside or outside the
path), pockets, and islands. Each operation or path group has its own depth.
The primary workspace is a 2D pan/zoom view; a 3D preview can be toggled.

**Typical use:** Flat panel parts, signs, gaskets, PCB cutouts, decorative
profiles, nested sheet parts.

### Input Formats

| Format | Notes |
|---|---|
| SVG | Primary format. Paths, groups, and layers map to operations. |
| DXF | Imported as 2D geometry. Layer names used to group operations. |
| Selected model edges | Edges from a loaded STEP/IGES projected to a chosen plane. |

### Operations Available

| Operation | Description |
|---|---|
| Profile — outside | Cuts around the outside of a closed path (part falls free) |
| Profile — inside | Cuts around the inside of a closed path (hole or cutout) |
| Profile — on-line | Cuts with tool center on the path (for engrave/scribe) |
| Pocket | Clears material inside a closed boundary |
| Island pocket | Pocket with one or more shapes left standing inside |
| Drill | Point operations at circle centers auto-detected from artwork |
| Tab retention | Leaves bridges at intervals to prevent parts falling free |

Depth can vary per operation (or per layer in SVG/DXF), but within a single
operation the Z depth is fixed — this is what makes it purely 2D.

### UI Paradigm

The primary workspace is a **2D canvas** (not a 3D viewport):
- Pan and zoom on the XY plane
- Paths and regions displayed in their natural 2D form
- Operations shown as colored overlays on the artwork
- 3D preview generated on demand — simple extruded mesh, no OCCT required

### Architecture Implications

**OCCT is not needed** for this mode. The geometry pipeline is:

```
SVG / DXF parser (Rust)
        │
        ▼
2D path data (Vec<Polyline>, Vec<ClosedRegion>)
        │
        ├── Clipper2: offset by tool radius, boolean ops for islands
        │
        ▼
2D toolpath (flat array of XY points with Z depth per pass)
        │
        ▼
Post-processor (same engine as solid modes)
```

The 3D preview mesh is generated by extruding the 2D paths to their cut depths
using simple geometry math — no B-rep, no tessellation.

**SVG parsing:** `usvg` crate (parses and normalizes SVG into a path tree).
**DXF parsing:** `dxf` crate.

This mode can be implemented without any of the OCCT infrastructure being
complete, making it a good candidate for an early standalone prototype.

---

## Mode 2: V-Carve

**What it is:** The input is 2D vector artwork but the toolpath is 3D — a
V-bit descends to a depth that varies with the local width of each stroke or
shape. The result is a carved appearance where narrow features are cut shallowly
and wide features are cut deeply, with the V-bit walls meeting the surface
exactly at the artwork boundary.

**Typical use:** Sign lettering, decorative carving, relief insets, wood
carving, artistic CNC work.

### V-Carve Geometry

For a V-bit with included angle α and a path whose local half-width at a given
point is `w/2`:

```
depth = (w/2) / tan(α/2)
```

The tool tip traces the **medial axis** of the 2D shape at varying depths.
The medial axis is the locus of centers of all maximal inscribed circles — it
is the skeleton of the shape.

```
  artwork boundary
  ╭──────────────────────╮
  │     ←  w  →          │
  │          ●  ← medial axis point at depth d = (w/2)/tan(α/2)
  │                       │
  ╰──────────────────────╯
```

### Variants

#### Standard V-Carve

The V-bit traces the full medial axis. No flat-bottom — the bit goes as deep
as the local width demands. Works best for lettering and shapes where no region
is too wide for the tool.

#### Flat-Bottom V-Carve (V-Carve + Pocket)

When a shape is wider than `max_depth × 2 × tan(α/2)`, the center area cannot
be reached with the V-bit at the target depth. Solution:
1. A flat endmill clears the center area to `max_depth` first
2. The V-bit then carves the edges to the full profile depth

The boundary between the pocket region and the V-carved region is computed
by intersecting the medial axis depth field with `max_depth`.

#### Inlay V-Carve

Two pieces are cut that fit together — the female pocket and a male inlay
piece. Common for decorative wood inlay.

**Female piece (pocket):** Cut with standard V-carve.

**Male piece (inlay):**
- Cut on the back face of the inlay material
- The geometry is the mirror image, but offset inward by a small gap (typically
  0.1–0.2mm) for glue clearance
- The perimeter of the male piece must be cut as a profile with tabs

Both pieces are generated from the same artwork. The user specifies the
V-bit angle, max depth, and glue gap.

#### Paint-Fill / Color-Fill

The same V-carve geometry, but the intent is to fill the cuts with paint, epoxy,
or a contrasting material. This is a **metadata flag** on the operation, not
a different algorithm. The 3D preview renders the cuts filled with a user-chosen
color, showing how the finished piece will look.

#### Relief Relief Carve (Wood-Block Print)

The background is carved away to leave the artwork raised. The inverse of
a standard V-carve. The operations are:
1. V-carve the outline of each shape (as the boundary between raised and
   lowered areas)
2. Pocket-clear the background down to a flat depth

### Input Formats

Same as Mode 1 (SVG, DXF, selected model edges). Additionally:
- Bitmap tracing: import a raster image and trace to vector automatically
  (using an external tool like `potrace` as a pre-processing step, or a
  bundled Rust implementation)

### Key Algorithm: Medial Axis Transform

The medial axis of a 2D shape is non-trivial to compute robustly for
arbitrary input. Two approaches:

| Approach | Quality | Complexity |
|---|---|---|
| Voronoi-based (exact) | High | High — requires robust Voronoi of curved segments |
| Progressive inward offset | Good enough | Medium — Clipper2 used iteratively |

**Phase 1 implementation:** progressive inward offset (Clipper2). At each
offset step, the distance from the original boundary is known; this gives the
depth at each centerline point. Sufficient for lettering and most sign work.

**Phase 2 (later):** exact medial axis via Straight Skeleton algorithm.
The straight skeleton gives exact medial axis for polygonal input and is the
correct solution for complex shapes.

### Architecture Implications

- V-carve is a new algorithm module in `toolpath/operations/vcarve.rs`
- The medial axis / straight skeleton computation is a significant piece of
  geometry work, independent of OCCT
- The `CutPoint.orientation` remains `(0, 0, 1)` — V-carve is 3-axis
- The 3D preview mesh can be generated analytically from the V-carve geometry
  (the swept V-bit profile) without OCCT booleans
- Inlay computation needs careful handling of the gap offset and the male
  piece perimeter profile

---

## Mode 3: Relief / Heightmap

**What it is:** The input is a 2D grayscale image or grid of Z values where
pixel intensity represents surface height. The machine carves the surface to
match this height field. No solid model, no B-rep — just a function `Z = f(X, Y)`.

**Typical use:** Topographic maps, lithophanes (backlit thin panels where
depth creates the image), artistic relief carving, texture carving, portrait
carving.

### Input Formats

| Format | Notes |
|---|---|
| PNG / TIFF (grayscale) | Pixel intensity → Z height, normalized to depth range |
| PNG / TIFF (inverted) | For lithophanes: bright = thin = transmits more light |
| RAW heightmap | 16-bit or 32-bit float grid |
| Generated (procedural) | Fractal terrain, mathematical functions — possible future |

The user specifies:
- Physical size (mm) of the image
- Z depth range (min and max depth, mapped to 0 and 255 intensity)
- Invert flag (for lithophanes)

### Operations Available

| Operation | Notes |
|---|---|
| Parallel (raster) | Most common — constant-direction scan across the height field |
| Scallop | Variable spacing for constant surface finish quality |
| Roughing passes | Coarse passes before finishing, for deep reliefs |

All operations drive a ball-nose or tapered ball-nose into the height field.
The height field is sampled at each X position to find Z.

### Architecture Implications

**OCCT is not needed.** The height field is represented as a 2D grid (a
`Vec<Vec<f32>>` or a flat `Vec<f32>` with stride). Surface normals are computed
analytically from finite differences.

```
Heightmap (2D grid of f32 Z values)
        │
        ├── sample_z(x, y)     → bilinear interpolation
        ├── normal_at(x, y)    → finite difference gradient
        └── passes:            parallel scan lines at step-over intervals,
                               Z sampled from height field at each XY point
```

This is a substantially simpler pipeline than solid-model machining.
Performance is excellent — heightmaps are just array lookups with interpolation.

A new trait `SurfaceModel` can abstract over heightmaps and OCCT B-rep faces,
allowing the same parallel/scallop algorithms to work on both:

```rust
pub trait SurfaceModel: Send {
    fn sample_z(&self, x: f64, y: f64) -> f64;
    fn normal_at(&self, x: f64, y: f64) -> Vec3;
    fn bounds(&self) -> BoundingBox2D;
}

// Implementations:
pub struct HeightmapSurface { ... }
pub struct OcctFaceSurface  { face: OcctFace }
```

### 3D Preview

The heightmap is rendered directly as a `THREE.PlaneGeometry` with Z displacement
applied to each vertex. Fast, no IPC needed for the geometry — the frontend
generates the mesh from the same heightmap data it received for display.

---

## Mode 4: Rotary (X, Z, θ)

**What it is:** One of the three linear axes is replaced by a rotary axis.
The machine has X (along the stock axis), Z (radial depth), and A (rotation
around X). There is no independent Y axis — Y motion is achieved by rotating
the stock. Used for turning cylindrical or near-cylindrical objects on a
router or mill with a rotary axis attachment.

**Typical use:** Table legs, balusters, rolling pins, baseball bats, wine
bottle holders, cylindrical signs, fluted columns, cams.

### Coordinate Model

The workpiece is mounted horizontally, rotating around the X axis. The tool
approaches from above (Z axis) or from the side (depending on the machine).

```
         Z (tool descends)
         │
         │       ┌────────────────────────── X (along stock)
         │      ╱
         │     ╱   stock rotates around X → A axis (degrees)
         │    ╱
         └───╱
```

G-code axes: `X`, `Z`, `A` (or `B` depending on machine convention).

Feed rate in rotary mode can be expressed as:
- `mm/min` (linear equivalent at the surface — depends on current diameter)
- `deg/min` (pure angular rate)
- `rev/min` × feed/rev (like lathe turning)

### Input Formats

| Format | Notes |
|---|---|
| Profile curve | 2D profile that is revolved — defines the outer surface |
| 3D solid (STEP) | Cylindrical or near-cylindrical object, unwrapped |
| Heightmap (cylindrical) | Grayscale image treated as a cylindrical unwrap |
| SVG (unwrapped) | 2D artwork treated as a cylindrical surface wrap |

### Operations Available

| Operation | Description |
|---|---|
| Roughing (profile) | Rough the outer profile to shape |
| Finishing (profile) | Finish the surface from a revolved profile |
| Fluting | Cut longitudinal or helical flutes (channels) |
| Cylindrical relief | Carve a heightmap or artwork wrapped around the cylinder |
| Indexing (rotary wrap) | Standard 2D operations applied to the unwrapped surface |

### Viewport Presentation

The viewport shows the cylindrical workpiece in 3D. An unwrapped 2D view
(like a texture map) is available alongside for artwork placement.

Toolpath is displayed both on the 3D cylinder and on the unwrapped view.

### Architecture Implications

- A new coordinate transformer converts between XZ+angle and Cartesian XYZ
- `CutPoint` stays in Cartesian; the post-processor converts to X/Z/A
- The post-processor for rotary machines gets a new section:

```toml
[rotary]
enabled       = true
axis          = "A"          # "A" or "B"
diameter_word = "X"          # some controllers use X as diameter in rotary mode
feed_mode     = "surface"    # "surface" (mm/min at surface) or "angular" (deg/min)
```

- Feed rate calculation requires the current stock diameter at the cut point
  to convert between surface speed and angular rate

---

## Mode 5: Multi-Setup Solid 3D

**What it is:** The same solid part is machined in multiple operations where
the part is re-fixtured between setups. Each setup has its own WCS. The
simplest case is a single flip (machine top face, flip, machine bottom face).
More complex cases involve 90° rotations or custom fixture orientations.

**Typical use:** Parts that need features on multiple faces: through-holes,
pockets on opposite sides, features that can't be reached from one direction.

### Setup Types

| Type | Description |
|---|---|
| Flip (180° around X or Y) | Most common — machine one face, flip the stock |
| 90° rotation | Machine a side face after setting up in a vise or angle plate |
| Custom orientation | Any arbitrary fixture orientation, described by a rotation matrix |
| Trunnion / compound angle | Fixed compound angle fixture |

### Project Structure

Each setup is a group of operations sharing a WCS. The `.jcam` project file
already supports multiple WCS entries (see `project-file-format.md`). In
multi-setup mode, the UI makes this structure visible:

```
Setup 1 — G54 (Top)
  ├── Operation: Adaptive Rough
  ├── Operation: Profile Finish
  └── Operation: Drill 6× M4

Setup 2 — G55 (Bottom, flipped)
  ├── Operation: Profile Bottom
  └── Operation: Drill 4× M6 (from bottom)
```

### Alignment Features

To ensure setups are aligned (so features from setup 1 and setup 2 meet
correctly), the user defines **reference features** — typically:
- A datum hole drilled in setup 1 that a locating pin uses in setup 2
- Two corners of a reference face that establish the flip position

These are declared in the project and shown in the viewport as alignment
annotations. The post-processor emits a comment block showing the expected
fixture position for each setup.

### Architecture Implications

- Multi-setup is primarily a **project organization** and **UI** concern —
  the toolpath engine for each setup is unchanged
- Operations are tagged with a `setup_id` (which WCS they belong to)
- The post-processor generates either:
  - One file per setup (`bracket_setup1.nc`, `bracket_setup2.nc`)
  - One combined file with setup separators and operator prompts (`M00` stops)
- The viewport shows all setups simultaneously (each in its WCS), or can
  isolate one setup at a time

---

## Mode 6: Rotary 4-Axis (X, Y, Z, A simultaneous)

**What it is:** Four axes move simultaneously. Three linear axes (X, Y, Z)
plus one rotary axis (A — rotation around X, or B — rotation around Y). The
rotary axis is not indexed between operations but moves continuously during
cutting.

**Typical use:** Cam lobes, spiral flutes on cutting tools, impeller blades
(simplified vs 5-axis), complex turned forms with off-center features, port
machining.

### Distinction from Rotary (X, Z, θ) — Mode 4

| | Mode 4 (X, Z, θ) | Mode 6 (X, Y, Z, A) |
|---|---|---|
| Linear axes | 2 (X, Z) | 3 (X, Y, Z) |
| Rotary purpose | Replaces Y — cylindrical positioning | Adds orientation DOF |
| Typical stock | Cylindrical, horizontal | Any shape |
| Tool approach | Radial from above | Any direction (in XY plane) |
| G-code | X, Z, A | X, Y, Z, A |

### Operations Available

The standard 3D surface operations (parallel, scallop, flowline) are extended
with tool axis tilt around the rotary axis — the A angle tilts the effective
tool orientation in the XZ plane.

This is a subset of 5-axis capability: only one rotary degree of freedom.
The kinematics are simpler than full 5-axis.

### Architecture Implications

- Uses the same `CutPoint` struct as 5-axis — `orientation` carries the tool
  axis vector
- The kinematics solver for 4-axis is simpler than 5-axis:
  ```
  A = atan2(-ix, iz)    (rotation around X to align tool in XZ plane)
  ```
- The post-processor emits X, Y, Z, A words
- No B or C axis motion

---

## Mode 7: Full 5-Axis

Covered in `toolpath-engine.md` and `gcode-postprocessor.md`. Included here
for completeness in the mode taxonomy.

**X, Y, Z** (linear) + **two rotary axes** (A+C, B+C, or A+B depending on
machine configuration). All five axes can move simultaneously.

---

## Implementation Phasing

The modes are implemented in a sequence that builds on prior work:

```
Phase 1 (MVP)
  └── Mode 1: 2D Vector — no OCCT, validates SVG/DXF pipeline and post-processor

Phase 1b (concurrent with or just after Phase 1)
  └── Mode 2: V-Carve (basic) — progressive offset medial axis, standard V-carve

Phase 2 (2.5D)
  ├── Mode 2: V-Carve (flat-bottom, inlay variants)
  └── Mode 3: Relief / Heightmap — simple parallel raster of a height field

Phase 3 (3D Surface)
  └── Mode 5: Multi-Setup — project organization + post-processor support

Phase 4 (5-axis)
  ├── Mode 4: Rotary (X, Z, θ) — rotary coordinate transform + post-processor
  ├── Mode 6: Rotary 4-axis — subset of 5-axis kinematics
  └── Mode 7: Full 5-axis

Post Phase 4
  └── Mode 2: V-Carve (straight skeleton exact medial axis)
```

Note that **Mode 1 (2D Vector) can be developed almost entirely independently**
of the OCCT/solid pipeline. It shares only the post-processor engine and the
project file format. This makes it a strong candidate for an early parallel
workstream once Phase 0 infrastructure is complete.

---

## Mode Selector in the UI

When the user creates a new project, a mode selection dialog presents the
options. The selected mode determines:

- Which file formats appear in the "Open Model" dialog
- Which panels and operation types are visible
- Whether the viewport is 2D-primary or 3D-primary
- Which post-processor settings are relevant (rotary axis config, etc.)

The mode is stored in `project.json` and cannot be changed after project
creation (to avoid invalid state). The user would create a new project to
switch modes.

Projects created in simpler modes (2D Vector, V-Carve) can optionally be
**upgraded** to a more complex mode — e.g., a 2D Vector project can be
re-opened as a Solid 3D project if the user has added a 3D model. This upgrade
path is one-way and explicit.

---

## Relationship to Existing Architecture Documents

| Mode | Primary impact on existing docs |
|---|---|
| 2D Vector | Adds SVG/DXF input path; `geometry-kernel.md` not needed; `toolpath-engine.md` gets `contour`, `pocket` from purely 2D source |
| V-Carve | New algorithm section in `toolpath-engine.md`; medial axis is new geometry module |
| Relief / Heightmap | New `SurfaceModel` trait in `toolpath-engine.md`; no OCCT changes |
| Multi-Setup | Already partially covered in `project-file-format.md` (multiple WCS); post-processor gains setup separation |
| Rotary (X,Z,θ) | New section in `gcode-postprocessor.md` (rotary axis config); new coordinate transform module |
| 4-axis | Subset of 5-axis kinematics in `gcode-postprocessor.md` |
| 5-axis | Already fully covered |

---

*Document status: Draft*
*Related documents: `toolpath-engine.md`, `gcode-postprocessor.md`, `project-file-format.md`, `system-architecture.md`*
